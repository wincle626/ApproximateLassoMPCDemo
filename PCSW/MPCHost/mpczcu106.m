%% add path
%!!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! !!! 
% Must change path according to the local matlab installation
para.matlabinc = '/tools/MATLAB/R2022b/extern/include'; % matlab include path
addpath(genpath('./mex'),...
        genpath('./scripts'));
while(1)
    clear;
    clc;
    close all;
    
    %% Parameters
    model_spacecraft;
    MAX_ITER = 10;
    
    %%
    % When there are no constraints, the optimal predicted input sequence U(k)
    % generated by MPC controller is |-K*x|, where |K = inv(H)*F|.
    K = H\F;
    
    %% 
    % In practice, only the first control move |u(k) = -K_mpc*x(k)| is applied
    % to the plant (receding horizon control).
    K_mpc = K(1,:);
    
    % %% Matlab MPC Simulator
    % % Run a simulation with initial states at [0.5 -0.5]. The closed-loop
    % % response is stable.  
    t_unconstrained = 0:Ts:T*Ts;
    % u_unconstrained = zeros(size(t_unconstrained));
    % Unconstrained_MPC = tf([-1 1])*feedback(ss(A,B,eye(2),0,Ts),K_mpc);
    % figure;
    % lsim(Unconstrained_MPC,'-',u_unconstrained,t_unconstrained,x0)
    % legend show
    
    %% PGD
    x_pgd = x0;
    G = F * x_pgd;
    A_hat = (1/sqrt(2)) * H^(1/2);
    b_hat = (-1/sqrt(2)) * (H^(-1/2) * G);
    % L = max(eigs(A_hat));
    % lambda = 1/L;
    % gamma_max = norm(A_hat'*b_hat,'inf');
    % gamma = 0.1*gamma_max;
    lambda = 0.0002; % N=1 -> 0.01; N=5 -> 0.0035; N=10 -> 0.00035
    beta = 0.5; % N=1 -> 0.5; N=5 -> 0.5; N=10 -> 0.5
    gamma = 1.5;
    disp('PGD');
    % tic;
    uMPC_pgd = zeros(n,length(t_unconstrained));
    yMPC_pgd = zeros(size(C,1),length(t_unconstrained));
    AtA = A_hat'*A_hat;
    
    h2=figure(2);
    x1=100;
    y1=400;
    width1=800;
    height1=800;
    set(gcf,'position',[x1,y1,width1,height1])
    clf(h2);
    [ncomp, s, ...
    h17, h18, h19] = createObj();
    % h11, h12, h13, ...
    % h14, h15, h16, ...
    for ct = 1:length(t_unconstrained)
    % for ct = 1
        Atb = A_hat' * b_hat;
        % z = mpcclient(Atb.');
        % pause(0.6);
        % z = mpcclient(Atb.');
    %     pause(0.6);
        z = lassompc_pgd(AtA, Atb, m, n, N, ...
                         lambda, beta, gamma, MAX_ITER);
    %     [z, itr, lmd] = lassompc_pgd0(A_hat, b_hat, AtA, Atb, m, n, N, ...
    %                      lambda, beta, gamma, MAX_ITER);
    %     lambda = lmd*2;
    %     z = pgd_double(AtA, Atb, lambda, beta, gamma, MAX_ITER);
    %     z = pgd_float(AtA, Atb, lambda, beta, gamma, MAX_ITER);
    %     z = pgd_fpx(AtA, Atb, lambda, beta, gamma, MAX_ITER);
    %     z = pgd_fxp(AtA, Atb, lambda, beta, gamma, MAX_ITER);
    %     z = pgd_sp8(AtA, Atb, lambda, beta, gamma, MAX_ITER);
    %     z = pgd_sp16(AtA, Atb, lambda, beta, gamma, MAX_ITER);
    %     z = pgd_sp32(AtA, Atb, lambda, beta, gamma, MAX_ITER);
    %     z = pgd_spx(AtA, Atb, lambda, beta, gamma, MAX_ITER);
    %     client = tcpclient("192.168.137.106",9527);
    %     server = tcpserver("0.0.0.0",9527);
    %     write(client,Atb,"double");
    %     z = read(server,server.NumBytesAvailable,"double");
    %     clear client;
    %     clear server;
        uMPC_pgd(1:n,ct) = z(1:n);
        x_pgd = A*x_pgd+B*uMPC_pgd(1:n,ct);
        % x_pgd = min( [x_pgd xmax], [], 2 );
        % x_pgd = max( [x_pgd xmin], [], 2 );
        yMPC_pgd(1:size(C,1),ct) = C*x_pgd;
        % yMPC_pgd(1:size(C,1),ct) = min( [yMPC_pgd(1:size(C,1),ct) ymax], [], 2 );
        % yMPC_pgd(1:size(C,1),ct) = max( [yMPC_pgd(1:size(C,1),ct) ymin], [], 2 );
        G = F * x_pgd;
        b_hat = (-1/sqrt(2)) * (H^(-1/2) * G);
    %     gamma_max = norm(A_hat'*b_hat,'inf');
    %     gamma = 0.1*gamma_max;
    
        h1=figure(1);
        x0=1200;
        y0=700;
        width0=1024;
        height0=640;
        set(gcf,'position',[x0,y0,width0,height0])
        clf(h1);
        subfig1=subplot(4,1,1);
        hold on;
        for i = 1:size(uMPC_pgd,1)
            % stem(t_unconstrained(1:ct),max(min(uMPC_pgd(i,1:ct), ...
            %     umax(i)),umin(i)),'.--','linewidth',2,'MarkerSize',14);
            stem(t_unconstrained(1:ct),uMPC_pgd(i,1:ct), ...
                '.--','linewidth',2,'MarkerSize',14);
        end
        legend('$\tau_1$','$\tau_2$','$\tau_3$','$\tau_\omega$', ...
               'Interpreter','latex','FontSize',12);
        set(get(subfig1,'YLabel'), 'String', 'Voltage(V)')
        axis([0 3 -0.05 0.05]);
        grid on;
        subfig2=subplot(4,1,2);
        hold on;
        for i = 5:7
            % stem(t_unconstrained(1:ct),max(min(yMPC_pgd(i,1:ct), ...
            %     ymax(i)),ymin(i)),'.--','linewidth',2,'MarkerSize',14);
            stem(t_unconstrained(1:ct),yMPC_pgd(i,1:ct), ...
                '.--','linewidth',2,'MarkerSize',14);
        end
        legend('$Roll$','$Pitch$','$Yaw$', ...
               'Interpreter','latex','FontSize',12);
        set(get(subfig2,'YLabel'), 'String', 'Angel(Deg)')
        % axis([0 3 -0.05 0.05]);
        axis([0 3 -50 50]);
        grid on;
        subfig3=subplot(4,1,3);
        hold on;
        stem(t_unconstrained(1:ct),max(min(yMPC_pgd(4,1:ct), ...
            ymax(4)),ymin(4)),'.--','linewidth',2,'MarkerSize',14);
        % stem(t_unconstrained(1:ct),yMPC_pgd(4,1:ct), ...
        %     '.--','linewidth',2,'MarkerSize',14);
        legend('$\omega_\omega$', ...
               'Interpreter','latex','FontSize',12);
        set(get(subfig3,'YLabel'), 'String', 'Reaction(Rad/s)')
        % axis([0 3 -100 100]);
        axis([0 3 -600 600]);
        grid on;
        subfig4=subplot(4,1,4);
        hold on;
        for i = 1:3
            % stem(t_unconstrained(1:ct),max(min(yMPC_pgd(i,1:ct), ...
            %     ymax(i)),ymin(i)),'.--','linewidth',2,'MarkerSize',14);
            stem(t_unconstrained(1:ct),yMPC_pgd(i,1:ct), ...
                '.--','linewidth',2,'MarkerSize',14);
        end
        legend('$\omega_1$','$\omega_2$','$\omega_3$', ...
               'Interpreter','latex','FontSize',12);
        set(get(subfig4,'YLabel'), 'String', 'Thruster(Deg/s)')
        % % axis([0 3 -0.05 0.05]);
        axis([0 3 -50 50]);
        grid on;
    
    %     mpc3dgui([yMPC_pgd(7,ct) yMPC_pgd(6,ct) yMPC_pgd(5,ct)], h2);
        h2=figure(2);
        x1=100;
        y1=400;
        width1=800;
        height1=800;
        set(gcf,'position',[x1,y1,width1,height1])
        rotateObj(ncomp, s, ... 
            h17, h18, h19, ...
            yMPC_pgd(7,ct)/pi, yMPC_pgd(6,ct)/pi, yMPC_pgd(5,ct)/pi);
    %         h11, h12, h13, ...
    %         h14, h15, h16, ...
    %     pause(0.5)
    end

end % while loop

% if libisloaded('libsocketlib')
%     unloadlibrary('libsocketlib')
% end
% sum(abs(x(1:n) - z(1:n)'))
% for i = 1:length(yMPC_pgd(:,1))
%     disp(std(yMPC_pgd(i,:)));
%     disp(mean(yMPC_pgd(i,:)));
% end

% toc;
% h7=figure;
% subplot(4,1,1);
% hold on;
% for i = 1:size(uMPC_pgd,1)
%     plot(t_unconstrained,max(min(uMPC_pgd(i,:),umax(i)),umin(i)),'linewidth',2);
% end
% legend('$\tau_1$','$\tau_2$','$\tau_3$','$\tau_\omega$', ...
%        'Interpreter','latex');
% grid on;
% subplot(4,1,2);
% hold on;
% for i = 5:7
%     plot(t_unconstrained,max(min(yMPC_pgd(i,:),ymax(i)),ymin(i)),'linewidth',2);
% end
% legend('$Roll$','$Pitch$','$Yaw$', ...
%        'Interpreter','latex');
% grid on;
% subplot(4,1,3);
% plot(t_unconstrained,max(min(yMPC_pgd(4,:),ymax(4)),ymin(4)),'linewidth',2);
% legend('$\omega_\omega$', ...
%        'Interpreter','latex');
% grid on;
% subplot(4,1,4);
% hold on;
% for i = 1:3
%     plot(t_unconstrained,max(min(yMPC_pgd(i,:),ymax(i)),ymin(i)),'linewidth',2);
% end
% legend('$\omega_1$','$\omega_2$','$\omega_3$', ...
%        'Interpreter','latex');
% grid on;


%% subfunctions
function x_cvx = qpmpc_cvx(H, F, x, n, N)
    cvx_begin quiet
        cvx_precision low
        variable x_opt(n*N)
        minimize(0.5 * x_opt' * H * x_opt + (F * x)' * x_opt)
    cvx_end  
    x_cvx = x_opt;
end

function x_cvx = lassompc_cvx(A, b, n, N, gamma)
    cvx_begin quiet
        cvx_precision low
        variable x(n*N)
        minimize(sum_square(A * x - b)+gamma*l1_norm(x))
%         minimize(sum_square((1/sqrt(2)) * H^(1/2) * x_cvx - (-1/sqrt(2)) * (H^(-1/2) * G)))
    cvx_end
    x_cvx = x;
end

function x_cvx = lassompc_cvx1(A, b, n, N, gamma, umax, umin)
    cvx_begin quiet
        cvx_precision low
        variable x(n*N)
        minimize(sum_square(A * x - b)+gamma*l1_norm(x))
        subject to
            umin <= x <= umax;
%         minimize(sum_square((1/sqrt(2)) * H^(1/2) * x_cvx - (-1/sqrt(2)) * (H^(-1/2) * G)))
    cvx_end
    x_cvx = x;
end

function x_admm = lassompc_admm(A_hat, Atb, U, L, m, n, N, ...
                      lambda, rho, gamma, MAX_ITER)
%     x = zeros(nN*N,1);
    z = zeros(n*N,1);
    u = zeros(n*N,1);
    for k = 1:MAX_ITER
        % x-update
        q = Atb + rho*(z - u);
        if m >= n
           x = U \ (L \ q);
        else
           x = lambda*(q - lambda*(A_hat'*(U \ ( L \ (A_hat*q) ))));
        end
        % z-update
        z = prox_l1(x + u, lambda*gamma);
        % u-update
        u = u + rho*(x - z);
    end
    x_admm = z;
end

function p = objective(A, b, gamma, x, z)
    p = 0.5*sum_square(A*x - b) + gamma*norm(z,1);
end

function [x_pgd, itr, lambda] = lassompc_pgd0(A, b, AtA, Atb, m, n, N, ...
                              lambda, beta, gamma, MAX_ITER)
    f = @(u) 0.5*sum_square(A*u-b);
    x_pgd = zeros(n*N,1);
    itr = 0;
    for k = 1:MAX_ITER
        x_pgd_1 = x_pgd;
        while 1
            itr = itr + 1;
            grad_x = AtA*x_pgd_1 - Atb;
            z = prox_l1(x_pgd_1 - lambda*grad_x, lambda*gamma);
            if f(z) <= f(x_pgd_1) + grad_x'*(z - x_pgd_1) + (1/(2*lambda))*sum_square(z - x_pgd_1)
                break;
            end
            lambda = beta*lambda;
        end
        x_pgd = z;

        h.prox_optval(k) = objective(A, b, gamma, x_pgd, x_pgd);
        if k > 1 && abs(h.prox_optval(k) - h.prox_optval(k-1)) < 1e-4
            break;
        end
    end
%     disp(itr);
%     disp(lambda);
end

function x_pgd = lassompc_pgd(AtA, Atb, m, n, N, ...
                              lambda, beta, gamma, MAX_ITER)
    x_pgd = zeros(n*N,1);
    for k = 1 : MAX_ITER
        x_pgd_1 = x_pgd;
%         % Compute gradient
% %         grad_x = A_hat*x_pgd + b_hat;
%         grad_x = AtA*x_pgd_1 - Atb;
%         % Proximal mapping
%         x_pgd = x_pgd_1 - lambda*grad_x;
%         z = prox_l1(x_pgd, lambda*gamma);
        grad_x = AtA*x_pgd_1 - Atb;
        z = prox_l1(x_pgd_1 - lambda*grad_x, lambda*gamma);
%         if lambda >= 8.5300e-05
            lambda = beta*lambda;
%         end
        x_pgd = z;
    end
end

function x = prox_l1(v, lambda)
% PROX_L1    The proximal operator of the l1 norm.
%
%   prox_l1(v,lambda) is the proximal operator of the l1 norm
%   with parameter lambda.

    x = max(0, v - lambda) - max(0, -v - lambda);
end

function [L, U, invU, invL] = factor(A, rho)
    [m, n] = size(A);
    if m >= n
       L = chol(A'*A + rho*speye(n), 'lower');
    else
       L = chol(speye(m) + 1/rho*(A*A'), 'lower');
    end
    invU = pinv(L'); invL = pinv(L);
    L = sparse(L);
    U = sparse(L');
end

function y = l0_norm(x)
    y = sum(x~=0);
end

function y = l1_norm(x)
    y = sum(abs(x));
end

function y = l2_norm(x)
    y = sum(abs(x).^2);
end

function y = linf_norm(x)
    y = max(abs(x));
end
